name: Daily Health Check

on:
  schedule:
    # Run every day at 8:00 AM US/Chicago (14:00 UTC)
    - cron: "0 14 * * *"
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: read
  issues: write # Needed to create issues on failure

jobs:
  health-check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: develop

      # --- Backend Setup & Test ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install Backend Dependencies
        run: |
          cd backend
          python -m venv venv
          source venv/bin/activate
          pip install -r ../requirements.txt
          pip install -r ../requirements.txt
          pip install pytest pytest-cov

      - name: Run Backend Tests & Coverage
        id: backend
        run: |
          cd backend
          source venv/bin/activate
          # Run tests and output coverage report to terminal. Fail under 50%.
          set -o pipefail
          pytest --cov=. --cov-report=term-missing --cov-fail-under=50 tests/ 2>&1 | tee ../backend_test.log
        continue-on-error: true

      # --- Frontend Setup & Test ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci

      - name: Run Frontend Tests & Coverage
        id: frontend
        run: |
          cd frontend
          # Fail if coverage is under 50%
          set -o pipefail
          npm run test:run -- --coverage --coverage.thresholds.lines=50 2>&1 | tee ../frontend_test.log
        continue-on-error: true

      # --- Reporting ---
      - name: Create Issue on Failure
        if: always() && (steps.backend.outcome == 'failure' || steps.frontend.outcome == 'failure')
        uses: actions/github-script@v7
        env:
          BACKEND_OUTCOME: ${{ steps.backend.outcome }}
          FRONTEND_OUTCOME: ${{ steps.frontend.outcome }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toLocaleDateString();

            // Helper to clean logs
            function stripAnsi(str) {
              return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            }

            let backendLog = '';
            let frontendLog = '';

            try { backendLog = stripAnsi(fs.readFileSync('backend_test.log', 'utf8')); } catch (e) { backendLog = 'Log file not found.'; }
            try { frontendLog = stripAnsi(fs.readFileSync('frontend_test.log', 'utf8')); } catch (e) { frontendLog = 'Log file not found.'; }

              // Helper to extract relevant failure lines and coverage table
            function getFailureSummary(log) {
              if (!log) return 'No log available (Step might have been skipped).';
              const lines = log.split('\n');
              
              // 1. Capture Failures
              const failures = lines.filter(l => l.includes('FAILED') || l.includes('Error:') || l.includes('FAIL'));
              
              // 2. Capture Coverage Table (Look for the header and the following lines)
              let coverageTable = [];
              let insideCoverage = false;
              for (const line of lines) {
                if (line.includes('Name') && line.includes('Stmts') && line.includes('Miss')) {
                    insideCoverage = true;
                }
                if (insideCoverage) {
                    coverageTable.push(line);
                    // Stop if we hit the limit or the end of the table
                    if ((line.includes('TOTAL') && coverageTable.length > 5) || coverageTable.length > 500) {
                        insideCoverage = false;
                    }
                }
                if (!insideCoverage && coverageTable.length > 0 && line.trim() === '') {
                     break; 
                }
              }
              
              let output = '';
              if (failures.length > 0) {
                 output += `### âŒ Detected Failures:\n\`\`\`\n${failures.slice(0, 15).join('\n')}\n...\n\`\`\`\n\n`;
              }
              
              if (coverageTable.length > 0) {
                 output += `### ðŸ“Š Coverage Gaps:\n\`\`\`\n${coverageTable.join('\n')}\n\`\`\`\n\n`;
              } else {
                 const summary = lines.slice(-20).join('\n');
                 output += `### ðŸ“‹ Log Summary:\n\`\`\`\n${summary}\n\`\`\``;
              }
              
              // Hard truncate removed in favor of splitting into comments
              return output;
            }

            // Helper to create issue and comments if needed
            async function createIssue(type, summary, log, outcome) {
              if (outcome !== 'failure' && !summary.includes('FAILED')) return; // Only create issue on failure

              const fullBody = `The Daily Health Check for **${type}** failed on ${date}. 
                
                ## Status: ${outcome.toUpperCase()}
                
                ### ðŸ“‹ Failure Summary
                ${summary}
                
                ---
                [View Full Actions Log](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

              const MAX_CHAR = 60000;
              let issueBody = fullBody;
              let remainingParts = [];

              if (fullBody.length > MAX_CHAR) {
                  issueBody = fullBody.substring(0, MAX_CHAR) + '\n\n**(Continued in comments)**';
                  let remaining = fullBody.substring(MAX_CHAR);
                  while (remaining.length > 0) {
                      remainingParts.push(remaining.substring(0, MAX_CHAR));
                      remaining = remaining.substring(MAX_CHAR);
                  }
              }

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `ðŸš¨ ${type} Health Check Failed: ${date}`,
                body: issueBody,
                labels: ['bug', 'automated-report', 'coverage', type.toLowerCase()]
              });

              for (const part of remainingParts) {
                  await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.data.number,
                      body: part
                  });
              }
            }

            const backendSummary = getFailureSummary(backendLog);
            const frontendSummary = getFailureSummary(frontendLog);

            if (process.env.BACKEND_OUTCOME === 'failure') {
              await createIssue('Backend', backendSummary, backendLog, process.env.BACKEND_OUTCOME);
            }

            if (process.env.FRONTEND_OUTCOME === 'failure') {
              await createIssue('Frontend', frontendSummary, frontendLog, process.env.FRONTEND_OUTCOME);
            }

            // Also create a summary issue if BOTH failed (optional, but requested "create github issues")
            // Actually user said "create github issues for front and backend". Plural. So separate is good.

            // Fail the workflow if any step failed
            // Fail the workflow if any step failed
            if (process.env.BACKEND_OUTCOME === 'failure' || process.env.FRONTEND_OUTCOME === 'failure') {
              core.setFailed("One or more health checks failed. See created issues for details.");
            }
