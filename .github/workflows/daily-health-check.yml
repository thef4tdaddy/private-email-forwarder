name: Daily Health Check

on:
  schedule:
    # Run every day at 8:00 AM US/Chicago (14:00 UTC)
    - cron: "0 14 * * *"
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: read
  issues: write # Needed to create issues on failure

jobs:
  health-check:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          ref: develop

      # --- Backend Setup & Test ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install Backend Dependencies
        run: |
          cd backend
          python -m venv venv
          source venv/bin/activate
          pip install -r ../requirements.txt
          pip install -r ../requirements.txt
          pip install pytest pytest-cov

      - name: Run Backend Tests & Coverage
        id: backend
        run: |
          cd backend
          source venv/bin/activate
          # Run tests and output coverage report to terminal. Fail under 50%.
          set -o pipefail
          pytest --cov=. --cov-report=term-missing --cov-fail-under=50 tests/ 2>&1 | tee ../backend_test.log
        continue-on-error: true

      # --- Frontend Setup & Test ---
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci

      - name: Run Frontend Tests & Coverage
        id: frontend
        run: |
          cd frontend
          # Fail if coverage is under 50%
          set -o pipefail
          npm run test:run -- --coverage --coverage.thresholds.lines=50 2>&1 | tee ../frontend_test.log
        continue-on-error: true

      # --- Reporting ---
      - name: Create Issue on Failure OR Success
        if: always()
        uses: actions/github-script@v7
        env:
          BACKEND_OUTCOME: ${{ steps.backend.outcome }}
          FRONTEND_OUTCOME: ${{ steps.frontend.outcome }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toLocaleDateString();

            // Helper to clean logs
            function stripAnsi(str) {
              return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            }

            let backendLog = '';
            let frontendLog = '';

            try { backendLog = stripAnsi(fs.readFileSync('backend_test.log', 'utf8')); } catch (e) { backendLog = 'Log file not found.'; }
            try { frontendLog = stripAnsi(fs.readFileSync('frontend_test.log', 'utf8')); } catch (e) { frontendLog = 'Log file not found.'; }

              // Helper to extract relevant failure lines and coverage table
            function getFailureSummary(log) {
              if (!log) return 'No log available (Step might have been skipped).';
              const lines = log.split('\n');
              
              // 1. Capture Failures
              const failures = lines.filter(l => l.includes('FAILED') || l.includes('Error:') || l.includes('FAIL'));
              
              // 2. Capture Coverage Table (Look for the header and the following lines)
              let coverageTable = [];
              let insideCoverage = false;
              for (const line of lines) {
                if (line.includes('Name') && line.includes('Stmts') && line.includes('Miss')) {
                    insideCoverage = true;
                }
                if (insideCoverage) {
                    coverageTable.push(line);
                    // Stop if we hit the limit or the end of the table
                    if ((line.includes('TOTAL') && coverageTable.length > 5) || coverageTable.length > 500) {
                        insideCoverage = false;
                    }
                }
                if (!insideCoverage && coverageTable.length > 0 && line.trim() === '') {
                     break; 
                }
              }
              
              let output = '';
              if (failures.length > 0) {
                 output += `### âŒ Detected Failures:\n\`\`\`\n${failures.slice(0, 15).join('\n')}\n...\n\`\`\`\n\n`;
              }
              
              if (coverageTable.length > 0) {
                 output += `### ðŸ“Š Coverage Gaps:\n\`\`\`\n${coverageTable.join('\n')}\n\`\`\`\n\n`;
              } else {
                 const summary = lines.slice(-20).join('\n');
                 output += `### ðŸ“‹ Log Summary:\n\`\`\`\n${summary}\n\`\`\``;
              }
              
              // Hard truncate removed in favor of splitting into comments
              return output;
            }

            // Helper to create issue and comments if needed
            async function createIssue(type, summary, log, outcome) {
              // Create issue for BOTH success and failure to show coverage gaps
              
              const icon = outcome === 'failure' ? 'ðŸš¨' : 'âœ…';
              const title = `${icon} ${type} Health Check ${outcome === 'failure' ? 'Failed' : 'Report'}: ${date}`;
              
              const fullBody = `The Daily Health Check for **${type}** finished with status: **${outcome.toUpperCase()}**
                
                ### ðŸ“Š Coverage & Analysis
                ${summary}
                
                ---
                [View Full Actions Log](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

              // --- Issue Splitting Logic ---
              const MAX_CHAR = 60000;
              let issueBody = fullBody;
              let remainingParts = [];

              if (fullBody.length > MAX_CHAR) {
                  issueBody = fullBody.substring(0, MAX_CHAR) + '\n\n**(Continued in comments)**';
                  let remaining = fullBody.substring(MAX_CHAR);
                  while (remaining.length > 0) {
                      remainingParts.push(remaining.substring(0, MAX_CHAR));
                      remaining = remaining.substring(MAX_CHAR);
                  }
              }

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: issueBody,
                labels: ['bug', 'automated-report', 'coverage', type.toLowerCase()]
              });

              for (const part of remainingParts) {
                  await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.data.number,
                      body: part
                  });
              }

              // --- Auto-Create Individual Coverage Tasks ---
              // Only do this on success or partial success to avoid spamming during catastrophic failure
              try {
                  await manageCoverageIssues(type, summary);
              } catch (e) {
                  console.log(`Failed to create coverage tasks: ${e.message}`);
              }
            }

            async function manageCoverageIssues(type, logSummary) {
                const lines = logSummary.split('\n');
                const lowCoverageFiles = [];
                
                // Flexible parsing for Pytest-cov (simple) and Vitest (table)
                // Default threshold: 80%
                for (const line of lines) {
                    const row = line.split(/\s+|\|/).filter(Boolean); // Split by whitespace or pipe
                    // Very naive heuristic: valid rows have a filename and some numbers
                    // Frontend: File | % Stmts | ...
                    // Backend: Name | Stmts | Miss | Cover
                    
                    if (row.length < 4) continue;
                    
                    const filename = row[0];
                    if (!filename.includes('.') || filename === 'File' || filename === 'Name' || filename.includes('---')) continue;

                    // Look for a percentage that is low
                    const percentages = row.filter(item => item.match(/^\d+(\.\d+)?%?$/)).map(p => parseFloat(p));
                    const coverage = percentages.find(p => p < 80); // Find first metric below 80%

                    if (coverage !== undefined) {
                        lowCoverageFiles.push({ file: filename, coverage });
                    }
                }
                
                // Rate Limit: Top 3 worst offenders only
                lowCoverageFiles.sort((a, b) => a.coverage - b.coverage);
                const candidates = lowCoverageFiles.slice(0, 3);
                
                for (const item of candidates) {
                    const issueTitle = `test(coverage): Improve coverage for ${item.file} (${item.coverage}%)`;
                    
                    // Check for existing issue
                    const existing = await github.rest.search.issuesAndPullRequests({
                        q: `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open in:title "Improve coverage for ${item.file}"`
                    });
                    
                    if (existing.data.total_count === 0) {
                        await github.rest.issues.create({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            title: issueTitle,
                            body: `Automated Coverage Task\n\nFile: \`${item.file}\`\nCurrent Coverage: **${item.coverage}%**\n\nPlease write tests to improve coverage for this file above 80%.`,
                            labels: ['coverage-gap', 'help-wanted', `area:${type.toLowerCase()}`]
                        });
                        console.log(`Created task for ${item.file}`);
                    } else {
                        console.log(`Task already exists for ${item.file}`);
                    }
                }
            }

            const backendSummary = getFailureSummary(backendLog);
            const frontendSummary = getFailureSummary(frontendLog);

            // Report on Backend
            if (process.env.BACKEND_OUTCOME) {
               await createIssue('Backend', backendSummary, backendLog, process.env.BACKEND_OUTCOME);
            }

            // Report on Frontend
            if (process.env.FRONTEND_OUTCOME) {
               await createIssue('Frontend', frontendSummary, frontendLog, process.env.FRONTEND_OUTCOME);
            }

            // Also create a summary issue if BOTH failed (optional, but requested "create github issues")
            // Actually user said "create github issues for front and backend". Plural. So separate is good.

            // Fail the workflow if any step failed
            // Fail the workflow if any step failed
            if (process.env.BACKEND_OUTCOME === 'failure' || process.env.FRONTEND_OUTCOME === 'failure') {
              core.setFailed("One or more health checks failed. See created issues for details.");
            }
