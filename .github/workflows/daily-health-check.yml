name: Daily Health Check

on:
  schedule:
    # Run every day at 8:00 AM US/Chicago (14:00 UTC)
    - cron: "0 14 * * *"
  workflow_dispatch: # Allow manual trigger

permissions:
  contents: read
  issues: write

jobs:
  full-salvo:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- Setup ---
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install Backend Dependencies
        run: |
          cd backend
          python -m venv venv
          source venv/bin/activate
          pip install -r ../requirements.txt
          pip install pytest pytest-cov black ruff mypy

      - name: Install Frontend Dependencies
        run: |
          cd frontend
          npm ci
          npx playwright install --with-deps

      # --- Backend Salvo ---
      - name: Backend Linting (Black, Ruff, Mypy)
        id: backend_lint
        run: |
          cd backend
          source venv/bin/activate
          {
            echo "::group::Black"
            python -m black --check .
            echo "::endgroup::"
            echo "::group::Ruff"
            python -m ruff check .
            echo "::endgroup::"
            echo "::group::Mypy"
            python -m mypy . --ignore-missing-imports
            echo "::endgroup::"
          } 2>&1 | tee ../backend_lint.log
        continue-on-error: true

      - name: Backend Tests (Pytest)
        id: backend_test
        run: |
          cd backend
          source venv/bin/activate
          # Run tests and output coverage report. Fail under 50%.
          pytest --cov=. --cov-report=term-missing --cov-fail-under=50 tests/ 2>&1 | tee ../backend_test.log
        continue-on-error: true

      # --- Frontend Salvo ---
      - name: Frontend Linting (Prettier, ESLint, Svelte Check)
        id: frontend_lint
        run: |
          cd frontend
          {
            echo "::group::Prettier"
            npx prettier --check "src/**/*.{ts,js,svelte,css}"
            echo "::endgroup::"
            echo "::group::ESLint"
            npm run lint
            echo "::endgroup::"
            echo "::group::Svelte Check"
            npm run check
            echo "::endgroup::"
          } 2>&1 | tee ../frontend_lint.log
        continue-on-error: true

      - name: Frontend Tests (Vitest)
        id: frontend_test
        run: |
          cd frontend
          # Fail if coverage is under 50%
          npm run test:run -- --coverage --coverage.thresholds.lines=50 2>&1 | tee ../frontend_test.log
        continue-on-error: true

      - name: Frontend E2E (Playwright)
        id: e2e
        run: |
          cd frontend
          npx playwright test 2>&1 | tee ../e2e_test.log
        continue-on-error: true

      # --- Reporting ---
      - name: Generate Daily Health Report
        if: always()
        uses: actions/github-script@v7
        env:
          OUTCOME_BACKEND_LINT: ${{ steps.backend_lint.outcome }}
          OUTCOME_BACKEND_TEST: ${{ steps.backend_test.outcome }}
          OUTCOME_FRONTEND_LINT: ${{ steps.frontend_lint.outcome }}
          OUTCOME_FRONTEND_TEST: ${{ steps.frontend_test.outcome }}
          OUTCOME_E2E: ${{ steps.e2e.outcome }}
        with:
          script: |
            const fs = require('fs');
            const date = new Date().toLocaleDateString();

            // Helper to clean logs
            function stripAnsi(str) {
              return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '');
            }

            // Read all logs
            const logs = {
              backend_lint: '',
              backend_test: '',
              frontend_lint: '',
              frontend_test: '',
              e2e: ''
            };

            for (const key of Object.keys(logs)) {
              try { 
                logs[key] = stripAnsi(fs.readFileSync(`${key}.log`, 'utf8')); 
              } catch (e) { 
                logs[key] = 'Log file not found (Step might have been skipped).'; 
              }
            }

            // Outcomes map
            const outcomes = {
              'Backend Linting': process.env.OUTCOME_BACKEND_LINT,
              'Backend Tests': process.env.OUTCOME_BACKEND_TEST,
              'Frontend Linting': process.env.OUTCOME_FRONTEND_LINT,
              'Frontend Tests': process.env.OUTCOME_FRONTEND_TEST,
              'Frontend E2E': process.env.OUTCOME_E2E
            };

            // Determine Overall Status
            const overallStatus = Object.values(outcomes).every(o => o === 'success') ? 'success' : 'failure';
            const icon = overallStatus === 'success' ? 'âœ…' : 'ðŸš¨';
            const title = `${icon} Daily Health Report: ${date}`;

            // Build Summary Table
            let summaryTable = `| Component | Status | Outcome |\n|---|---|---|\n`;
            for (const [name, outcome] of Object.entries(outcomes)) {
              const statusIcon = outcome === 'success' ? 'âœ…' : 'âŒ';
              summaryTable += `| ${name} | ${statusIcon} | ${outcome.toUpperCase()} |\n`;
            }

            // Helper to extract failure details (simplified)
            function getBriefLog(log) {
              if (!log) return '';
              const lines = log.split('\n');
              // Grab failures or errors
              const failures = lines.filter(l => l.includes('FAILED') || l.includes('Error:') || l.includes('FAIL') || l.includes('âœ˜'));
              if (failures.length > 0) {
                 return failures.slice(0, 10).join('\n') + (failures.length > 10 ? '\n...' : '');
              }
              // If no explicit failure lines, grep tail
              return lines.slice(-10).join('\n');
            }

            // Build Detailed Body
            let details = '';
            for (const [key, log] of Object.entries(logs)) {
               // Only show details if failed
               const outcomeKey = {
                 'backend_lint': 'Backend Linting',
                 'backend_test': 'Backend Tests',
                 'frontend_lint': 'Frontend Linting',
                 'frontend_test': 'Frontend Tests',
                 'e2e': 'Frontend E2E'
               }[key];
               
               if (outcomes[outcomeKey] === 'failure') {
                   details += `### âŒ Failure Details: ${outcomeKey}\n\`\`\`\n${getBriefLog(log)}\n\`\`\`\n\n`;
               }
            }

            // Add Coverage Summaries (even on success)
            function getCoverageTable(log) {
               // Simple extraction of the table part
               const lines = log.split('\n');
               let table = [];
               let capture = false;
               for (const line of lines) {
                  if (line.includes('Name') && line.includes('Stmts') || line.includes('File') && line.includes('Stmts')) capture = true;
                  if (capture) {
                      table.push(line);
                      if ((line.includes('TOTAL') || line.includes('All files')) && table.length > 5) break;
                      if (table.length > 20) { table.push('... (truncated)'); break; }
                  }
               }
               return table.length > 0 ? table.join('\n') : '';
            }

            const backendCov = getCoverageTable(logs.backend_test);
            const frontendCov = getCoverageTable(logs.frontend_test);

            if (backendCov) details += `### ðŸ“Š Backend Coverage\n\`\`\`\n${backendCov}\n\`\`\`\n\n`;
            if (frontendCov) details += `### ðŸ“Š Frontend Coverage\n\`\`\`\n${frontendCov}\n\`\`\`\n\n`;

            const fullBody = `**Full Salvo Verification Status**: ${overallStatus.toUpperCase()}

            ${summaryTable}

            ---
            ${details}

            [View Full Actions Log](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`;

             // --- Issue Splitting & Creation ---
              const MAX_CHAR = 60000;
              let issueBody = fullBody;
              let remainingParts = [];

              if (fullBody.length > MAX_CHAR) {
                  issueBody = fullBody.substring(0, MAX_CHAR) + '\n\n**(Continued in comments)**';
                  let remaining = fullBody.substring(MAX_CHAR);
                  while (remaining.length > 0) {
                      remainingParts.push(remaining.substring(0, MAX_CHAR));
                      remaining = remaining.substring(MAX_CHAR);
                  }
              }

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: issueBody,
                labels: ['automated-report', 'daily-health', overallStatus]
              });

              for (const part of remainingParts) {
                  await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.data.number,
                      body: part
                  });
              }

              // --- Auto-Create Coverage Tasks ---
              async function manageCoverageIssues(type, logSummary) {
                // ... (Existing Logic Preserved) ...
                const lines = logSummary.split('\n');
                const lowCoverageFiles = [];
                for (const line of lines) {
                    const row = line.split(/\s+|\|/).filter(Boolean);
                    if (row.length < 4) continue;
                    const filename = row[0];
                    if (!filename.includes('.') || filename === 'File' || filename === 'Name' || filename.includes('---')) continue;
                    const percentages = row.filter(item => item.match(/^\d+(\.\d+)?%?$/)).map(p => parseFloat(p));
                    const coverage = percentages.find(p => p < 80);
                    if (coverage !== undefined) {
                        lowCoverageFiles.push({ file: filename, coverage });
                    }
                }
                lowCoverageFiles.sort((a, b) => a.coverage - b.coverage);
                const candidates = lowCoverageFiles.slice(0, 3);
                for (const item of candidates) {
                    const issueTitle = `test(coverage): Improve coverage for ${item.file} (${item.coverage}%)`;
                    const existing = await github.rest.search.issuesAndPullRequests({
                        q: `repo:${context.repo.owner}/${context.repo.repo} is:issue is:open in:title "Improve coverage for ${item.file}"`
                    });
                    if (existing.data.total_count === 0) {
                        await github.rest.issues.create({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            title: issueTitle,
                            body: `Automated Coverage Task\n\nFile: \`${item.file}\`\nCurrent Coverage: **${item.coverage}%**\n\nRun \`daily-health-check\` to see progress.`,
                            labels: ['coverage-gap', 'help-wanted', `area:${type.toLowerCase()}`]
                        });
                        console.log(`Created task for ${item.file}`);
                    }
                }
            }

            try { await manageCoverageIssues('Backend', logs.backend_test); } catch(e) {}
            try { await manageCoverageIssues('Frontend', logs.frontend_test); } catch(e) {}

            // Mark Run as Failed if Overall Status is failure
            if (overallStatus === 'failure') {
                core.setFailed("Daily Health Check failed. See report issue.");
            }
